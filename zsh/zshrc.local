# vim: set sw=4 ts=4 sts=4 et tw=78 foldmarker={{,}} foldlevel=0 foldmethod=marker nospell:
# @author: Haoming Wang <haoming.exe@gmail.com>

# Imports {{

safe_source() { [[ -s $1 ]] && source $1 || return 0 }

safe_source ~/.zshrc.before.local

for file in ~/.common/*; do
    safe_source $file
done

# }}

# Utils {{

program_exists vim && alias vi=vim
program_exists nvim && alias vim=nvim

cut_last_n_cols() {
    # remove last n columns
    echo "$1" | rev | cut -d'/' -f"$(($2+1))"- | rev
}

alias sh='bash'

alias sd='sudo shutdown now'

alias open='xdg-open'

alias head="head -n $((${LINES:=`tput lines 2>/dev/null || echo -n 12`} - 3))"
alias tail="tail -n $((${LINES:=`tput lines 2>/dev/null || echo -n 12`} - 3))"

# Create a new directory and enter it
mk() {
    mkdir -p "$@" && cd "$_";
}

cdd() { cd ~/Documents/code/$1 }

add-head() {
    # add text to the beginning or the specified line of a file
    # if the given line number is greater than total number of lines, do nothing
    local file=$1
    local text=$2
    local line=${3:=1}
    if [[ -s $file ]] then;
        sed -i "${line}s/^/${text}\n/" $file
    else
        echo $text >> $file
    fi
}

empty-trash() {
    setopt localoptions rmstarsilent
    setopt localoptions nonomatch
    is_linux && {
        rm -rf ~/.local/share/Trash/files/{,.}*
        rm -rf ~/.local/share/Trash/info/{,.}*
    }
}

alias alert='notify-send -u low -i $([ $? -eq 0 ] && echo terminal || echo error)'

# }} // namespace utils

# Tools {{

# Awk {{

program_exists awk && {
    alias awk-last="awk '{print \$NF}'"
    awk-program-home() {
        awk -F"/" '{for(i=1;i<NF-2;i++) printf $i"/"; print $(NF-2)}'
    }
}

# }}

# Tmux {{

alias txls='tmux ls | xargs -I {} echo {} | cut -d: -f1'
alias txrm='tmux kill-session -t'

program_exists tmux && {
    txat() {
        [[ "$#" -ge 1 ]] && tmux attach -t $1 || tmux attach
    }

    txcl() {
        local args=$(txls)
        while IFS=' ' read -A sessions; do
            for session in "${sessions[@]}"; do
                echo "deleting session #$session"
                txrm $session
            done
        done <<< "$args"
    }
}

# }} // namespace tmux

# Git {{

alias gbrm='git branch -D'
alias gbcu='git rev-parse --abbrev-ref HEAD'
alias groot='git rev-parse --show-toplevel 2>/dev/null'

gbrmo() {
    git branch | grep -v $(gbcu) | xargs -r git branch -D
}

gbrm_remote() {
    local branch_to_delete=${1:=$(gbcu)}
    git push origin :$branch_to_delete
}

gitd() {
    local parsed_date=$(date --date=$1 +%F 2>/dev/null)
    [[ -z $parsed_date ]] && { error "Invalid date: $1"; return 1 }
    local desc="$parsed_date $(date +%T)"
    success $desc
    shift
    GIT_AUTHOR_DATE=$desc GIT_COMMITTER_DATE=$desc git $@
}

cdr() {
    # cd to git repo root
    local repo=$(groot)
    [[ -n $repo ]] && cd $repo || {
        echo "$(pwd) is not a git repo"
        return 1
    }
}

# }} // namespace git

# Package manager {{

program_exists apt && {
    # for debian/ubuntu
    alias pS='sudo apt install'
    alias pSs='apt search'
    alias pSy='sudo apt update'
    alias pSu='sudo apt upgrade'
    alias pSyu='sudo apt update && sudo apt upgrade'
    alias pR='sudo apt purge'
    alias pRa='sudo apt autoremove'
    essential="curl git-gui tmux htop tree net-tools clang clang-format \
        python3-distutils"
}

program_exists pacman && {
    # for archlinux
    alias pS='sudo pacman -S --needed'
    alias pSs='pacman -Ss'
    alias pSy='sudo pacman -Sy'
    alias pSu='sudo pacman -Su'
    alias pSyu='sudo pacman -Syu'
    alias pR='sudo pacman -R'
    alias pRa='[[ -n `pacman -Qdt` ]] && sudo pacman -Rns `pacman -Qdtq` || \
        echo "No orphans to remove"'
    essential="wget tk tmux htop tree xclip python-neovim neovim net-tools \
        xdg-utils ttf-dejavu ttf-ubuntu-font-family"
}

program_exists brew && {
    # for macOS
    alias pS='brew install'
    alias pSs='brew search'
    alias pSy='brew update'
    alias pSu='brew upgrade'
    alias pSyu='brew update && brew upgrade'
    alias pR='brew uninstall'
    alias pRa='brew cleanup'
    essential="wget"
}

[[ -n $essential ]] && alias install-essential='pS $(echo $essential)'

# }} // namespace package_manager

# }} // namespace tools

# Python {{

# Pip {{

alias is_venv='which python | grep -q "envs\|venv"'

alias pyenv_name='program_exists conda && is_venv && \
    which python | rev | cut -d'/' -f3 | rev'

alias piprm='pip uninstall -y'
alias pipls='pip freeze | grep -v certifi'
alias pipcl='is_venv && pipls | xargs pip uninstall -y'

# pypi
venv_upgrade() {
    is_venv && pip install --upgrade $@ || {
        error "Run this command in a virtual env"
        return 1
    }
}

pycompile() {
    venv_upgrade setuptools wheel || return 1
    [[ -f setup.py ]] && python setup.py sdist bdist_wheel || {
        error "Run this command from the same directory where setup.py is located"
        return 1
    }
}

pyupload() {
    venv_upgrade twine || return 1
    [[ -d dist ]] && twine upload dist/* || {
        error "'dist' folder not found or authentication failed"
        return 1
    }
}

alias pypi='pycompile && pyupload'

# }} // namespace pip

# Conda {{

program_exists conda && export CONDA_HOME=`cut_last_n_cols $(which python) $(is_venv && echo 4 || echo 2)`

alias u='source activate'
alias uu='conda deactivate'
alias uls='conda env list'
alias ucl='find $CONDA_HOME \( -type f -o -type l \) \
    -not -path "$CONDA_HOME/pkgs*" -regex ".*bin/wish[0-9\.]*$" -ls -delete'

program_exists conda && {

    uc() {
        [[ "$#" -lt 1 ]] && {
            error "missing operand: uc env_name [python_version]"
            return 1
        }
        conda create -n $1 python=${2:=3.6}
        ucl
        u $1
    }

    urm() {
        [[ "$#" -lt 1 ]] && {
            error "missing operand: urm env_name"
            return 1
        }
        if [[ $(pyenv_name) = "$1" ]]; then
            uu
        fi
        conda env remove -n $1
    }
}

# }} // namespace conda

# Pre-commit {{

set-pre-commit() {
    is_venv && pip install pre-commit || {
        error "Use a virtual env to setup pre-commit"
        return 1
    }
    local repo=$(groot)
    local name
    [[ -n $repo ]] && [[ -d $HOME/.linter ]] && {
        for file in $HOME/.linter/*; do
            name=$(parse $file)
            case $name in
                setup.cfg) ;;
                *) name=".$name" ;;  # hidden files
            esac
            [[ -f $repo/$name ]] || cpif $file "$repo/$name"
        done
        [[ -f "$repo/.git/hooks/pre-commit" ]] || pre-commit install
    } || {
        error "Not in a git repo or pre-commit not configured"
        return 1
    }
}

rm-pre-commit() {
    local repo=$(groot)
    if [[ -n $repo ]]; then
        rm -f "$repo/.git/hooks/pre-commit"
    fi
}

# }} // namespace pre-commit

# }} // namespace python

# Files {{

delete-type() {
    # recursively delete files of the given type
    find . -type f -name "*.$1" -ls -delete
}

delete-folder() {
    find . -type d -name $1 -ls -delete
}

alias rmds='delete-type DS_Store'
alias rmpyc='delete-type pyc && delete-folder __pycache__'

alias rmvim='rm -rf ~/.*vim* ~/.config/nvim'
alias rmzsh='rm -rf ~/.zsh ~/.zshrc.*'

# }} // namespace files

# Key bindings {{

bindkey '^ ' autosuggest-accept

# }} // namespace bindings

# Env {{

upd() {
    local env_name=$(pyenv_name)
    if [[ -n $env_name ]]; then
        echo "deactivating python virtual env: $env_name"
        uu
    fi
    success "updating zsh config"
    safe_source ~/.zshrc.local
    if [[ -n $env_name ]]; then
        echo "restoring python virtual env: $env_name"
        u $env_name
    fi
}

# path deduplication
program_exists awk && {
    LD_LIBRARY_PATH=$(echo -n "$LD_LIBRARY_PATH" | awk -v RS=: -v ORS=: '!a[$1]++' | head -c-1)
    PATH=$(echo -n "$PATH" | awk -v RS=: -v ORS=: '!a[$1]++' | head -c-1)
}

# }} // namespace env
