" vim: set sw=4 ts=4 sts=4 et tw=78 foldmarker={{,}} foldmethod=marker:
" @author: Haoming Wang <haoming.exe@gmail.com>

" Environment {{

" Identify platform {{
    silent function! MACOS()
        return has('macunix')
    endfunction
    silent function! LINUX()
        return has('unix') && !has('macunix') && !has('win32unix')
    endfunction
    silent function! WINDOWS()
        return has('win32')
    endfunction
" }}

" Basics {{
    set nocompatible        " Must be first line
    augroup vimrc
        autocmd!
    augroup END
" }}

" Windows Compatible {{
    " On Windows, also use '.vim' instead of 'vimfiles';
    " this makes synchronization across (heterogeneous) systems easier.
    if WINDOWS()
        set runtimepath=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME
    endif
" }}

" }} // namespace environment

" Bundles {{

let g:pyvim = has('python') || has('python3')

if has('nvim')
    let g:python_host_prog = '/usr/bin/python2'
    let g:python3_host_prog = '/usr/bin/python3'
endif

" list only the plugin groups you will use
if !exists('g:xming_plug_groups')
    let g:xming_plug_groups = ['general', 'editing', 'programming']
endif

call plug#begin('~/.vim/bundle')

" General {{
    if count(g:xming_plug_groups, 'general')
        Plug 'romainl/vim-cool'
        Plug 'junegunn/goyo.vim'
        Plug 'itchyny/lightline.vim'
        Plug 'haomingw/vim-startscreen'
        Plug 'rafi/awesome-vim-colorschemes'
    endif
" }}

" Editing {{
    if count(g:xming_plug_groups, 'editing')
        Plug 'chrisbra/csv.vim'
        Plug 'tpope/vim-repeat'
        Plug 'tpope/vim-endwise'
        Plug 'tpope/vim-surround'
        Plug 'rhysd/clever-f.vim'
        Plug 'junegunn/vim-easy-align'
        Plug 'easymotion/vim-easymotion'
        Plug 'terryma/vim-expand-region'
        Plug 'machakann/vim-highlightedyank'
        Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }
    endif
" }}

" Programming {{
    if count(g:xming_plug_groups, 'programming')
        Plug 'dense-analysis/ale'
        Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }
        Plug 'rust-lang/rust.vim'
        Plug 'leafgarland/typescript-vim'
        Plug 'mhinz/vim-signify'
        Plug 'tpope/vim-fugitive'
        Plug 'luochen1990/rainbow'
        Plug 'scrooloose/nerdcommenter'
        Plug 'AndrewRadev/splitjoin.vim'
        Plug 'haomingw/vim-snippets'
        Plug 'SirVer/ultisnips', g:pyvim ? {} : { 'on': [] }
        Plug 'majutsushi/tagbar', { 'on': 'TagbarToggle' }
        Plug 'Yggdroot/indentLine', { 'on': 'IndentLinesEnable' }
        Plug 'google/yapf', { 'rtp': 'plugins/vim', 'for': 'python' }
    endif
" }}

call plug#end()

" }} // namespace bundles

" General {{

syntax on                   " Syntax highlighting
set mouse=a                 " Automatically enable mouse usage
set mousehide               " Hide the mouse cursor while typing
scriptencoding utf-8

if has('clipboard')
    if has('unnamedplus') " When possible use + register for copy-paste
        set clipboard=unnamed,unnamedplus
    else
        " On mac and Windows, use * register for copy-paste
        set clipboard=unnamed
    endif
endif

if !exists('g:xming_no_restore_cursor')
    function! ResCur()
        if line("'\"") <= line("$")
            silent! normal! g`"
            return 1
        endif
    endfunction

    augroup resCur
        autocmd!
        autocmd BufWinEnter * call ResCur()
    augroup END
endif

" Choose 'visual bell' effect rather than 'beeping'.
set visualbell
set shortmess=at                " Abbrev. of messages (avoids 'hit enter')
" Better Unix / Windows compatibility
set viewoptions=folds,options,cursor,unix,slash
set virtualedit=onemore         " Allow for cursor beyond last character
set history=200
set hidden                      " Allow buffer switching without saving
set iskeyword-=.                " '.' is an end of word designator
set iskeyword-=#                " '#' is an end of word designator
set iskeyword-=-                " '-' is an end of word designator

set nobackup noswapfile nowritebackup
if has('persistent_undo')
    set undofile                " So is persistent undo ...
    set undodir=$HOME/.vim/undo
    " Maximum number of changes that can be undone
    set undolevels=1000
    " Maximum number lines to save for undo on a buffer reload
    set undoreload=10000
endif

" }} // namespace general

" Vim UI {{

set background=dark
try
    let ayucolor="mirage"       " light dark
    color ayu
    set termguicolors           " enable true colors support
catch
    color desert
endtry

set number                      " Line numbers on
set cursorline                  " Highlight current line
set noshowmode                  " Don't display the current mode
set showcmd                     " Show partial commands in status line
set backspace=indent,eol,start  " Backspace for dummies
set linespace=0                 " No extra spaces between rows
set showmatch                   " Show matching brackets/parenthesis
set incsearch                   " Find as you type search
set hlsearch                    " Highlight search terms
set winminheight=0              " Windows can be 0 line high
set ignorecase                  " Case insensitive search
set smartcase                   " Case sensitive when uc present
set wildmenu                    " Show list instead of just completing
set wildmode=list:longest,full  " Command <Tab> completion, list matches,
                                " then longest common part, then all.
set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wrap too
set scrolljump=5                " Lines to scroll when cursor leaves screen
set scrolloff=3                 " Minimum lines to keep above and below cursor
set foldenable                  " Auto fold code
set list
set laststatus=2                " Display status line

" Highlight problematic whitespace
set listchars=tab:›\ ,trail:•,extends:#,nbsp:.

" }} // namespace vim-ui

" Formatting {{

set nowrap
set autoindent                  " copy indent from previous line
set smartindent                 " enable nice indent

set shiftwidth=4                " Use indents of 4 spaces
set expandtab                   " Tabs are spaces, not tabs
set tabstop=4                   " An indentation every four columns
set softtabstop=4               " Let backspace delete indent

set splitright splitbelow
set pastetoggle=<F12>           " pastetoggle (sane indentation on pastes)
set nojoinspaces                " Prevents inserting two spaces after
                                " punctuation on a join (J)

" }} // namespace formatting

" Key (re)Mappings {{

" The default leader is '\', but many people prefer ' ' or ','
" as it's in a standard location.
let mapleader = ' '
let maplocalleader = ','

if !has('gui_running')
    try
        " fix meta-keys which generate <Esc>a .. <Esc>z
        let c = 'a'
        while c <= 'z'
            exec "set <A-".c.">=\e".c
            let c = nr2char(1+char2nr(c))
        endw
        set ttimeout ttimeoutlen=50
    catch
        " neovim
    endtry
endif

" qq to record, Q to replay
nnoremap Q @q

" Wrapped lines goes down/up to next row, rather than next line in file.
nnoremap j gj
nnoremap k gk

nnoremap n nzzzv
nnoremap N Nzzzv

" Allow to trigger background
function! ToggleBG()
    let s:tbg = &background
    " Inversion
    if s:tbg == "dark"
        set background=light
    else
        set background=dark
    endif
endfunction
nnoremap <leader>bg :call ToggleBG()<cr>

" Visual shifting (does not exit Visual mode)
vnoremap < <gv
vnoremap > >gv

cnoremap %% <c-r>=fnameescape(expand('%:h')).'/'<cr>
map <leader>ew :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%
map <leader>rp :%s/

map <Leader>= <c-w>=

" Switch between tabs
if MACOS()
    nnoremap ˙ gT
    nnoremap ¬ gt
else
    nnoremap <a-h> gT
    nnoremap <a-l> gt
endif

if MACOS()
    inoremap ˙ <Left>
    inoremap ∆ <Down>
    inoremap ˚ <Up>
    inoremap ¬ <Right>
else
    inoremap <a-h> <Left>
    inoremap <a-j> <Down>
    inoremap <a-k> <Up>
    inoremap <a-l> <Right>
endif

" Move tabs
if MACOS()
    nnoremap “ :call TabMove(-1)<cr>
    nnoremap ‘ :call TabMove(1)<cr>
else
    nnoremap <a-[> :call TabMove(-1)<cr>
    nnoremap <a-]> :call TabMove(1)<cr>
endif

inoremap <c-e> <End>
inoremap <c-a> <c-o>I
cnoremap <c-a> <Home>

" Window:
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l
nnoremap <c-k> <c-w>k
nnoremap <c-j> <c-w>j

" Fast editting
nnoremap <c-s> :w<cr>
nnoremap cl ggdG
inoremap <c-s> <Esc>:w<cr>a
inoremap <c-v> <Esc>pa
inoremap <c-j> <Esc>o
inoremap jj <Esc>O

inoremap <c-b> <c-o>b
inoremap <c-f> <c-o>w
inoremap <c-k> <c-o>D
" ctrl-h mapped to back space by default
inoremap <c-d> <Delete>

" undoable
inoremap <c-u> <c-g>u<c-u>
inoremap <c-w> <c-g>u<c-w>

" utils
nnoremap ; :
nnoremap Y y$
nnoremap <c-Up> <c-y>
nnoremap <c-Down> <c-e>
" yank text in command mode
cnoremap <c-v> <c-r>+

iabbrev tab2 vim: set sw=2 ts=2 sts=2 et
iabbrev tab4 vim: set sw=4 ts=4 sts=4 et

xnoremap @ :<C-u>call ExecuteMacroOverVisualRange()<CR>

" }} // namespace remapping

" Autocmd {{

augroup vimrc
    " Adjust viewports to the same size
    autocmd vimResized * exe "normal! \<c-w>="

    " Strip Trailing Whitespaces On Saving:
    " The 'e' flag to not give an error if there is no match
    autocmd BufWritePre *
        \ if &ft != 'markdown' && &ft != 'tex' | :silent %s/\s\+$//e | endif

    " File type settings
    autocmd FileType c :call C_setup()
    autocmd FileType cpp :call Cpp_setup()
    autocmd FileType python :call Python_setup()
    autocmd FileType rust :call Rust_setup()
    autocmd FileType yaml :call Tab2()
    autocmd FileType vim :call Tab2()
augroup END

" }} // namespace autocmd

" Plugins {{

" Ultisnips {{
    if has_key(g:plugs, 'ultisnips')
        " Trigger configuration. Do not use <tab>
        let g:UltiSnipsExpandTrigger = "<c-l>"
        " If you want :UltiSnipsEdit to split your window.
        let g:UltiSnipsEditSplit = "vertical"
    endif
" }}

" Vim-snippets {{
    if has_key(g:plugs, 'vim-snippets')
        let g:snips_author = $USER
    endif
" }}

" Goyo {{
    if has_key(g:plugs, 'goyo.vim')
        nnoremap <leader>gy :Goyo<cr>
    endif
" }}

" Lightline {{
    if has_key(g:plugs, 'lightline.vim')
        let g:lightline = {
        \ 'colorscheme': 'jellybeans',
        \ 'active': {
        \   'left': [ ['mode', 'paste'],
        \             ['fugitive', 'readonly', 'filename', 'modified'] ],
        \   'right': [ [ 'lineinfo' ], ['percent'] ]
        \ },
        \ 'component': {
        \   'readonly': '%{&filetype=="help"?"":&readonly?"🔒":""}',
        \   'modified': '%{&filetype=="help"?"":&modified?"+":&modifiable?"":"-"}',
        \   'fugitive': '%{exists("*fugitive#head")?fugitive#head():""}'
        \ },
        \ 'component_visible_condition': {
        \   'readonly': '(&filetype!="help"&& &readonly)',
        \   'modified': '(&filetype!="help"&&(&modified||!&modifiable))',
        \   'fugitive': '(exists("*fugitive#head") && ""!=fugitive#head())'
        \ },
        \ 'separator': { 'left': ' ', 'right': ' ' },
        \ 'subseparator': { 'left': ' ', 'right': ' ' }
        \ }
    endif
" }}

" Vim-easy-align {{
    if has_key(g:plugs, 'vim-easy-align')
        " Start interactive EasyAlign in visual mode (e.g. vipga)
        xmap ga <Plug>(EasyAlign)

        " Start interactive EasyAlign for a motion/text object (e.g. gaip)
        nmap ga <Plug>(EasyAlign)
    endif
" }}

" Vim-expand-region {{
    if has_key(g:plugs, 'vim-expand-region')
        xmap L <Plug>(expand_region_expand)
        xmap H <Plug>(expand_region_shrink)
    endif
" }}

" Vim-highlightedyank {{
    if has_key(g:plugs, 'vim-highlightedyank')
        if !exists('##TextYankPost')  " for older vim
            map y <Plug>(highlightedyank)
        endif
        let g:highlightedyank_highlight_duration = 100
        highlight HighlightedyankRegion cterm=reverse gui=reverse
    endif
" }}

" Nerdtree {{
    if has_key(g:plugs, 'nerdtree')
        nnoremap <leader>nt :NERDTreeToggle<cr>
        let g:NERDTreeDirArrowExpandable = '+'
        let g:NERDTreeDirArrowCollapsible = '-'
        augroup vimrc
            " close vim if the only window left open is a NERDTree
            autocmd bufenter *
                \ if (winnr("$") == 1 && exists("b:NERDTree") &&
                \ b:NERDTree.isTabTree()) | q | endif
        augroup END
        let NERDTreeIgnore = ['\.pyc$', '^__pycache__$']
    endif
" }}

" Rainbow {{
    if has_key(g:plugs, 'rainbow')
        " 0 if you want to enable it later via :RainbowToggle
        let g:rainbow_active = 1
    endif
" }}

" NerdCommenter {{
    if has_key(g:plugs, 'nerdcommenter')
        nmap <c-_> <leader>c<Space>j
        xmap <c-_> <leader>c<Space>j

        " Add spaces after comment delimiters by default
        let g:NERDSpaceDelims = 1
        " Allow commenting and inverting empty lines
        " (useful when commenting a region)
        let g:NERDCommentEmptyLines = 1
        " Align line-wise comment delimiters flush left
        " instead of following code indentation
        let g:NERDDefaultAlign = 'left'
    endif
" }}

" Tagbar {{
    if has_key(g:plugs, 'tagbar')
        let g:tagbar_sort = 0
        nnoremap <leader>tb :TagbarToggle<cr>
    endif
"}}

" Vim-signify {{
    if has_key(g:plugs, 'vim-signify')
        let g:signify_vcs_list = ['git']
        let g:signify_skip_filetype = { 'journal': 1 }
    endif
"}}

" Fugitive {{
    if has_key(g:plugs, 'vim-fugitive')
        nnoremap <silent> <leader>gs :Gstatus<cr>
        nnoremap <silent> <leader>gd :Gdiff<cr>
        nnoremap <silent> <leader>gc :Gcommit<cr>
        nnoremap <silent> <leader>gb :Gblame<cr>
        nnoremap <silent> <leader>gl :Glog<cr>
        nnoremap <silent> <leader>gp :Git push<cr>
        nnoremap <silent> <leader>gr :Gread<cr>
        nnoremap <silent> <leader>gw :Gwrite<cr>
        nnoremap <silent> <leader>ge :Gedit<cr>
        " Mnemonic _i_nteractive
        nnoremap <silent> <leader>gi :Git add -p %<cr>
        nnoremap <silent> <leader>gg :SignifyToggle<cr>
    endif
"}}

" indentLine {{
    if has_key(g:plugs, 'indentLine')
        autocmd! User indentLine doautocmd indentLine Syntax
        let g:indentLine_color_term = 239
        let g:indentLine_color_gui = '#616161'
        nnoremap <leader>il :IndentLinesEnable<cr>
    endif
" }}

" Easymotion {{
    if has_key(g:plugs, 'vim-easymotion')
        let g:EasyMotion_smartcase = 1
        " keep cursor column when JK motion
        let g:EasyMotion_startofline = 0

        map <leader>h <Plug>(easymotion-linebackward)
        map <leader>j <Plug>(easymotion-j)
        map <leader>k <Plug>(easymotion-k)
        map <leader>l <Plug>(easymotion-lineforward)
        map <leader>. <Plug>(easymotion-repeat)
    endif
" }}

" Ale {{
    if has_key(g:plugs, 'ale')
        let g:ale_echo_msg_error_str = 'E'
        let g:ale_echo_msg_warning_str = 'W'
        let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'

        " Only run linting when saving the file
        let g:ale_lint_on_text_changed = 'never'
        let g:ale_lint_on_insert_leave = 0
        " Don't run linters on opening a file
        let g:ale_lint_on_enter = 0

        " Only run linters named in ale_linters settings.
        let g:ale_linters_explicit = 1
        let g:ale_linters = {
        \   'cpp': 'all',
        \   'python': ['flake8', 'mypy', 'pylint'],
        \   'go': ['gofmt', 'golint', 'govet'],
        \   'rust': ['cargo'],
        \   'sh': ['shell'],
        \   'zsh': ['shell'],
        \   'markdown': 'all',
        \   'yaml': 'all',
        \}

        let g:ale_fixers = {
        \   'python': ['yapf'],
        \}
    endif

" }}

" Vim-go {{
    if has_key(g:plugs, 'vim-go')
        let g:go_fmt_command = "goimports"
        let g:go_highlight_fields = 1
        let g:go_highlight_function_calls = 1
    endif
" }}

" Rust.vim {{
    if has_key(g:plugs, 'rust.vim')
        let g:rustfmt_autosave = 0
    endif
" }}

" }} // namespace plugins

" GUI Settings {{

" GVIM- (here instead of .gvimrc)
if has('gui_running')
    set guioptions=             " remove all gui options
    set lines = 40                " 40 lines of text instead of 24
    if LINUX()
        set guifont=Courier\ 10\ Pitch\ Regular\ 12,
            \ Andale\ Mono\ Regular\ 12,
            \ Menlo\ Regular\ 11,
            \ Consolas\ Regular\ 12,
            \ Courier\ New\ Regular\ 14
    elseif MACOS()
        set guifont=Andale\ Mono:h12,
            \ Menlo:h11,Consolas:h12,
            \ Courier\ New:h14
    elseif WINDOWS()
        set guifont=Andale_Mono:h10,
            \ Menlo:h10,Consolas:h10,
            \ Courier_New:h10
    endif
else
    " Enable 256 colors to stop the CSApprox warning and
    " make xterm vim shine
    if &term == 'xterm' || &term == 'screen'
        set t_Co=256
    endif
endif

" }} // namespace gui

" Functions {{

function! Tab2()
    setlocal sw=2 ts=2 sts=2 et
endfunction

" Setup C file
function! C_setup()
    iabbrev inc #include
    iabbrev def #define
    iabbrev itn int
    iabbrev mian() main()
    call Tab2()

    if !filereadable(getcwd() . "/Makefile")
        let &makeprg='gcc % -DLOCAL'
    endif
endfunction

" Setup cpp file
function! Cpp_setup()
    call C_setup()
    iabbrev vi vector<int>
    iabbrev vvi vector<vector<int> >
    syn keyword cppType ll pii

    if !filereadable(getcwd() . "/Makefile")
        let &makeprg='g++ % -DLOCAL -std=c++11 -O2 -Wall -Wextra
            \ -Wpedantic -Wshadow -Wno-unused-result'
    endif

    " Clang format
    map <localleader>f :py3f ~/.vim/static/clang-format.py<cr>
endfunction

" Setup python file
function! Python_setup()
    iabbrev im import
    syn keyword pythonDecorator self

    if has_key(g:plugs, 'yapf')
        map <localleader>f :call yapf#YAPF()<cr>
    endif
    if has_key(g:plugs, 'ale')
        map <leader>f :ALEFix<cr>
    endif
endfunction

" Setup rust file
function! Rust_setup()
    if has_key(g:plugs, 'rust.vim')
        map <leader>f :RustFmt<cr>
    endif
endfunction

" Move current tab into the specified direction.
" @param direction -1 for left, 1 for right.
function! TabMove(direction)
    " get number of tab pages.
    let n = tabpagenr("$")
    let l:index = tabpagenr()
    if a:direction < 0
        let l:index = l:index - 2
        if l:index < 0
            let l:index = n
        endif
    else
        let l:index = l:index + 1
        if l:index > n
            let l:index = 0
        endif
    endif
    " move tab page.
    execute "tabmove " . l:index
endfunction

function! OnBattery()
    if MACOS()
        return match(system('pmset -g batt'), \
            "Now drawing from 'Battery Power'") != -1
    elseif LINUX()
        return readfile('/sys/class/power_supply/AC/online') == ['0']
    endif
    return 0
endfunction

function! ExecuteMacroOverVisualRange()
  echo "@".getcmdline()
  execute ":'<,'>normal @".nr2char(getchar())
endfunction

" }} // namespace functions
